---
layout: section
---
:notitle:
:description:
:author:
:email: jenkinsci-docs@googlegroups.com
:sectanchors:
:toc:
:hide-uri-scheme:

= Converting Condition Build Steps


Bascially, all the conditions map to `if/else` statements in Scripted Pipeline or
`stage/when` in Declarative Pipeline.
Some are more complex than others.

Scripted pipeline and Declarative differ significantly in how they handle conditional behavior.
It is worth discussing them separately.

== Scripted Pipeline


== Declarative Pipeline



== Conditions
The rest of this section will describe each of the conditions provided by
the Conditional BuildStep plugin and show the Pipeline equivalent.


[[always]]
=== Always

Always run steps. Provided for completeness.

.Pipeline
[pipeline]
----
// Declarative //
stage ('Example-1') {
    when {
        expression { true }
    }
    steps {
        echo 'Example step.'
    }
}
stage ('Example-2') {
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example-1') {
    if (true) {
        echo 'Example step.'
    }
}
stage ('Example-2') {
    echo 'Example step.' // <1>
}
----
<1> Condition is not needed for "always" case.


=== Never

Do not run steps.  Provided for completeness.

.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { false }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (false)
        echo 'Example step.' // <1>
    }
}
----
<1> This step will never be executed.

==== Boolean condition

You might think that a boolean condition would be the simplest condition, but it isn't.
Since it works with string values from tokens, the Conditional BuildStep plugin offers
a number of ways to indicate true or false.
Truth is a case-insensitive match of one of the following:
`1` (the number one), `Y`, `YES`, `T`, `TRUE`, `ON` or `RUN`.

[NOTE]
====
Pipeline can duplicate these, but depending on the scenario consider
whether a simpler expression would suffice.
====

.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression {
            truthPattern = /(?i)(Y|YES|T|TRUE|ON|RUN)/ // <1>
            token ==~ truthPattern // <2>
        }
    }
    steps {
        echo 'Example step.' // <3>
    }
}
// Script //
stage ('Example') {
    truthPattern = /(?i)(Y|YES|T|TRUE|ON|RUN)/ // <1>
    if (token ==~ truthPattern) { // <2>
        echo 'Example step.' // <3>
    }
}
----
<1> This is a Groovy
link:http://groovy-lang.org/syntax.html#_slashy_string[slashy string] representing
the case-insensitive "truth" values: `1` (the number one), `Y`, `YES`, `T`, `TRUE`, `ON` or `RUN`.
<2> `==~` is the Groovy regular expression
link:http://groovy-lang.org/operators.html#_match_operator[match operator].
<3> This step will be executed if `token` contains a string matching `truthPattern`.


[[logical]]
=== Logical Operations

These conditions wrap other conditions.
They take the result of other conditions as inputs
and perform a logical "and", "or", or "not" of the results.
They can be combined and chained as needed.

[[logical-and]]
==== "And" condition

.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { A && B }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (A && B) {
        echo 'Example step.' // <1>
    }
}
----
<1> This step will execute when both A and B return true.


[[logical-or]]
==== "Or" condition

.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { A || B }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (A || B) {
        echo 'Example step.' // <1>
    }
}
----
<1> This step will execute when A or B return true.

[[logical-not]]
==== "Not" condition

.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { !A }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (!A) {
        echo 'Example step.' // <1>
    }
}
----
<1> This step will execute when A is not true.

[[logical-examples]]
==== Examples: Combining Conditions

.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { !A }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (!A) {
        echo 'Example step.' // <1>
    }
}
----
<1> This step will execute when A is not true.

=== Build Cause

Runs steps if the current build has a specific cause (e.g triggered by SCM or timer).
Has an "Exclusive Cause" option that run steps only the current has only one specific cause.
The list of cause types can be extended by plugins.

This solution is based on code from the
link:https://jenkins.io/doc/pipeline/examples/#get-build-cause[pipeline examples],
which uses `currentBuild.rawBuild`.
If you see errors regarding 'Scripts not permitted to use method...' approve
these scripts at JENKINS_URL/scriptApproval/ - the UI shows the blocked methods

[IMPORTANT]
====
Using `currentBuild.rawBuild` has security risks.

link:https://issues.jenkins-ci.org/browse/JENKINS-41272[JENKINS-41272] has been filed
requesting causes be exposed on `currentBuild`.
====

.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression {
            expectedCauseType = hudson.model.Cause$UserIdCause // <1>
            return currentBuild.rawBuild.getCause(expectedCauseType) != null // <2>
        }
    }
    steps {
        echo 'Example step.' // <3>
    }
}
stage ('Example-Exclusive-Cause') {
    when {
        expression {
            expectedCauseType = hudson.model.Cause$UserIdCause // <1>
            buildCauses = currentBuild.rawBuild.getCauses() // <4>
            return buildCauses.size() == 1 &&
                buildCauses.get(0) instanceof expectedCauseType // <5>
        }
    }
    steps {
        echo 'Example step.' // <6>
    }
}
// Script //
stage ('Example') {
    expectedCauseType = hudson.model.Cause$UserIdCause // <1>
    if (currentBuild.rawBuild.getCause(expectedCauseType) != null) { // <2>
        echo 'Example step.' // <3>
    }
}
stage ('Example-Exclusive-Cause') {
    expectedCauseType = hudson.model.Cause$UserIdCause // <1>
    buildCauses = currentBuild.rawBuild.getCauses() // <4>
    if (buildCauses.size() == 1 &&
        buildCauses.get(0) instanceof expectedCauseType) { // <5>
        echo 'Example step.' // <6>
    }
}
----
<1> Example build cause type.  See list below for map of names to types.
<2> Get the first build cause of the specified type and check that it is not `null`
(`null` is the value returned when none of that type are found).
<3> This step will execute when at least one build cause matches the expected type.
<4> Get the full list of causes for the current build.
<5> Check if there is only one cause for the current build and that it matches the expected type.
<6> This step will execute when there is only one build cause and it matches the expected type.

*Known `Cause` types*:

* BuildResultTrigger -
link:http://javadoc.jenkins.io/plugin/buildresult-trigger/org/jenkinsci/plugins/buildresulttrigger/BuildResultTriggerCause.html[`org.jenkinsci.plugins.buildresulttrigger.BuildResultTriggerCause`],
* CLICause -
link:http://javadoc.jenkins-ci.org/hudson/cli/BuildCommand.CLICause.html[`hudson.cli.BuildCommand$CLICause`]
* FSTrigger -
link:http://javadoc.jenkins-ci.org/fstrigger/org/jenkinsci/plugins/fstrigger/FSTriggerCause.html[`org.jenkinsci.plugins.fstrigger.FSTriggerCause`],
* IvyTrigger -
link:http://javadoc.jenkins-ci.org/ivytrigger/org/jenkinsci/plugins/ivytrigger/IvyTriggerCause.html[`org.jenkinsci.plugins.ivytrigger.IvyTriggerCause`],
* LegacyCodeCause -
link:http://javadoc.jenkins-ci.org/hudson/model/Cause.LegacyCodeCause.html[`hudson.model.Cause$LegacyCodeCause`] _(Deprecated since 2009-02-08)_
* RemoteCause -
link:http://javadoc.jenkins-ci.org/hudson/model/Cause.RemoteCause.html[`hudson.model.Cause$RemoteCause`]
* SCMTrigger -
link:http://javadoc.jenkins-ci.org/hudson/triggers/SCMTrigger.SCMTriggerCause.html[`hudson.triggers.SCMTrigger$SCMTriggerCause`],
* ScriptTrigger -
link:http://javadoc.jenkins-ci.org/scripttrigger/org/jenkinsci/plugins/scripttrigger/ScriptTriggerCause.html[`org.jenkinsci.plugins.scripttrigger.ScriptTriggerCause`],
* TimerTrigger -
link:http://javadoc.jenkins-ci.org/hudson/triggers/TimerTrigger.TimerTriggerCause.html[`hudson.triggers.TimerTrigger$TimerTriggerCause`],
* UpstreamCause -
link:http://javadoc.jenkins-ci.org/hudson/model/Cause.UpstreamCause.html[`hudson.model.Cause$UpstreamCause`]
* UserIdCause -
link:http://javadoc.jenkins-ci.org/hudson/model/Cause.UserIdCause.html[`hudson.model.Cause$UserIdCause`]
* URLTrigger -
link:http://javadoc.jenkins-ci.org/urltrigger/org/jenkinsci/plugins/urltrigger/URLTriggerCause.html[`org.jenkinsci.plugins.urltrigger.URLTriggerCause`],
* UserCause -
link:http://javadoc.jenkins-ci.org/hudson/model/Cause.UserCause.html[`hudson.model.Cause$UserCause`] _(Deprecated: use "UserIdCause")_
* UserIdCause -
link:http://javadoc.jenkins-ci.org/hudson/model/Cause.UserIdCause.html[`hudson.model.Cause$UserIdCause`]


=== Current build status

Run if the current build status is within the configured range.

This condition will run the build step when the current build status is
equal to, or better than the "Worst status" and
is equal to or worse than the "Best status".

In Pipeline this value is accessed via `currentBuild.result`,
but the underlying values are the same.  The values and ordering are defined by the
link:http://javadoc.jenkins.io/hudson/model/Result.html[hudson.model.Result] class.

Result Values (best to worst): `SUCCESS`, `UNSTABLE`, `FAILURE`, `NOT_BUILT`, and `ABORTED`.

// TODO: Determine how to implement isBetterOrEqualTo and isWorseOrEqualTo
// for this example
// Related: https://issues.jenkins-ci.org/browse/JENKINS-41275

.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { false }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (false)
        echo 'Example step.' // <1>
    }
}
----
<1> This step will never be executed.


=== Day of week

Only run on specific days of the week.

Parameter: Days - Weekdays, Weekends, Select Days (Mon,Tue,Wed,Thu,Fri,Sat,Sun)

Option: "Use build time"

.Pipeline
[source,groovy]
----
if () { /* step */ }
----

=== Execute Shell

Runs a shell script (defaults to sh, uses same configuration as shell build step)
for checking the condition.

The script will be run with the workspace as the current directory.

.Pipeline
[source,groovy]
----
if () { /* step */ }
----

=== Execute Windows Batch

Runs a Windows batch script for checking the condition.

The script will be run with the workspace as the current directory.

.Pipeline
[source,groovy]
----
if () { /* step */ }
----

=== Execution node

Run only on selected nodes.

.Pipeline
[source,groovy]
----
if () { /* step */ }
----

=== File exists

Run if the file exists.
The file is expanded using the Token Macro Plugin.
If the file is relative, then it is relative to the Base directory.
If the file is absolute, then it will be tested on the Node that contains the Base directory (the master for $JENKINS_HOME and Artifacts dir).

.Pipeline
[source,groovy]
----
if () { /* step */ }
----

=== Files match

Run if one or more files match the selectors.
Separate multiple includes or excludes patterns with a comma. e.g. Includes "target/site/**/*.html,target/site/images/" Excludes "**/*.gif"
If no includes pattern is configured, then the pattern "**" will be used, which matches all files in the directory and all sub directories.
The includes and excludes are Ant Patterns.

.Pipeline
[source,groovy]
----
if () { /* step */ }
----

=== Numerical comparison

Run if the numerical comparison is true.
The Left hand side and the Right hand side will be expanded with the Token Macro Plugin.
Both arguments must evaluate to a number.
Check out the tokens provided by the Static Code Analysis Plugins for some awesome conditional execution options.

.Pipeline
[source,groovy]
----
if () { /* step */ }
----

=== Regular expression match
Run if the Expression matches the Label.
Both the Expression and the Label will be expanded with the Token Macro Plugin.
The Expression is a regular expression using the Java syntax.

////
Examples:

Parameterized publishing similar to the Publish Over family of publishers.
Select "This build is parameterized" from the top of the job configuration, and add a String parameter
Enter ${ENV,var="PARAMETER_NAME"} as the Expression
Give the publisher a Label e.g. UAT or RELEASE
Trigger a build passing in a regular expression as the value of PARAMETER_NAME e.g. INT|UAT
Use a fixed regular expression to match against a property value in a property file that is generated during the build.
////

.Pipeline
[source,groovy]
----
if () { /* step */ }
----

=== Strings match

Run if the two strings are the same.
Both of the strings will be expanded with the Token Macro Plugin.
The match can me made case insensitive by checking the box.

.Pipeline
[source,groovy]
----
if () { /* step */ }
----

=== Time

Only run during a certain period of the day.
The time is entered in 24 hour format, e.g. 5:03, 09:00, 22:45.
The time zone is the time zone set on the Jenkins master.
The time resolution is 1 minute, and the start minute and end minute are included in the range. i.e. 00:00 to 23:59 would match the whole day


.Pipeline
[source,groovy]
----
if () { /* step */ }
----
