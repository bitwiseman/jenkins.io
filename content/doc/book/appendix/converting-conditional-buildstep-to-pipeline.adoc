---
layout: section
---
:notitle:
:description:
:author:
:email: jenkinsci-docs@googlegroups.com
:sectanchors:
:toc:
:hide-uri-scheme:

= Converting Condition Build Steps


Bascially, all the conditions map to `if/else` statements in Scripted Pipeline or
`stage/when` in Declarative Pipeline.
Some are more complex than others.


Many conditions  support Token Macro expansion of inputs.
There is a separate page that discusses
link:./converting-tokens-to-pipeline.adoc[converting tokens to pipeline].


== Special Considerations

Scripted pipeline and Declarative differ significantly in how they handle conditional behavior.
It is worth discussing them separately.

=== Scripted Pipeline

=== Declarative Pipeline




== Conditions
The rest of this section will describe each of the conditions provided by
the Conditional BuildStep plugin and show the Pipeline equivalent.


[[always]]
=== Always

Always run steps. Provided for completeness.

.Pipeline
[pipeline]
----
// Declarative //
stage ('Example-1') {
    when {
        expression { true }
    }
    steps {
        echo 'Example step.'
    }
}
stage ('Example-2') {
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example-1') {
    if (true) {
        echo 'Example step.'
    }
}
stage ('Example-2') {
    echo 'Example step.' // <1>
}
----
<1> Condition is not needed for "always" case.


=== Never

Do not run steps.  Provided for completeness.

.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { false }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (false)
        echo 'Example step.' // <1>
    }
}
----
<1> This step will never be executed.

==== Boolean condition

You might think that a boolean condition would be the simplest condition, but it isn't.
Since it works with string values from tokens, the Conditional BuildStep plugin offers
a number of ways to indicate true or false.
Truth is a case-insensitive match of one of the following:
`1` (the number one), `Y`, `YES`, `T`, `TRUE`, `ON` or `RUN`.

[NOTE]
====
Pipeline can duplicate these, but depending on the scenario,
consider whether a simpler expression would suffice.
====

.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression {
            truthPattern = /(?i)(Y|YES|T|TRUE|ON|RUN)/ // <1>
            token ==~ truthPattern // <2>
        }
    }
    steps {
        echo 'Example step.' // <3>
    }
}
// Script //
stage ('Example') {
    truthPattern = /(?i)(Y|YES|T|TRUE|ON|RUN)/ // <1>
    if (token ==~ truthPattern) { // <2>
        echo 'Example step.' // <3>
    }
}
----
<1> This is a Groovy
link:http://groovy-lang.org/syntax.html#_slashy_string[slashy string] representing
the case-insensitive "truth" values: `1` (the number one), `Y`, `YES`, `T`, `TRUE`, `ON` or `RUN`.
<2> `==~` is the Groovy regular expression
link:http://groovy-lang.org/operators.html#_match_operator[match operator].
<3> This step will be executed if `token` contains a string matching `truthPattern`.


[[logical]]
=== Logical Operations

These conditions wrap other conditions.
They take the result of other conditions as inputs
and perform a logical "and", "or", or "not" of the results.
They can be combined and chained as needed.

[[logical-and]]
==== "And" condition

.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { A && B }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (A && B) {
        echo 'Example step.' // <1>
    }
}
----
<1> This step will execute when both A and B return true.


[[logical-or]]
==== "Or" condition

.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { A || B }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (A || B) {
        echo 'Example step.' // <1>
    }
}
----
<1> This step will execute when A or B return true.

[[logical-not]]
==== "Not" condition

.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { !A }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (!A) {
        echo 'Example step.' // <1>
    }
}
----
<1> This step will execute when A is not true.

[[logical-examples]]
==== Examples: Combining Conditions

[NOTE]
====
This example is not written yet.
====


.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { !A }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (!A) {
        echo 'Example step.' // <1>
    }
}
----
<1> This step will execute when A is not true.

=== Build Cause

Runs steps if the current build has a specific cause (e.g triggered by SCM or timer).
Has an "Exclusive Cause" option that run steps only the current has only one specific cause.
The list of cause types can be extended by plugins.

This solution is based on code from the
link:https://jenkins.io/doc/pipeline/examples/#get-build-cause[pipeline examples],
which uses `currentBuild.rawBuild`.
If you see errors regarding 'Scripts not permitted to use method...' approve
these scripts at JENKINS_URL/scriptApproval/ - the UI shows the blocked methods

[IMPORTANT]
====
Using `currentBuild.rawBuild` has security risks.

link:https://issues.jenkins-ci.org/browse/JENKINS-41272[JENKINS-41272] has been filed
requesting causes be exposed on `currentBuild`.
====

.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression {
            expectedCauseType = hudson.model.Cause$UserIdCause // <1>
            return currentBuild.rawBuild.getCause(expectedCauseType) != null // <2>
        }
    }
    steps {
        echo 'Example step.' // <3>
    }
}
stage ('Example-Exclusive-Cause') {
    when {
        expression {
            expectedCauseType = hudson.model.Cause$UserIdCause // <1>
            buildCauses = currentBuild.rawBuild.getCauses() // <4>
            return buildCauses.size() == 1 &&
                buildCauses.get(0) instanceof expectedCauseType // <5>
        }
    }
    steps {
        echo 'Example step.' // <6>
    }
}
// Script //
stage ('Example') {
    expectedCauseType = hudson.model.Cause$UserIdCause // <1>
    if (currentBuild.rawBuild.getCause(expectedCauseType) != null) { // <2>
        echo 'Example step.' // <3>
    }
}
stage ('Example-Exclusive-Cause') {
    expectedCauseType = hudson.model.Cause$UserIdCause // <1>
    buildCauses = currentBuild.rawBuild.getCauses() // <4>
    if (buildCauses.size() == 1 &&
        buildCauses.get(0) instanceof expectedCauseType) { // <5>
        echo 'Example step.' // <6>
    }
}
----
<1> Example build cause type.  See list below for map of names to types.
<2> Get the first build cause of the specified type and check that it is not `null`
(`null` is the value returned when none of that type are found).
<3> This step will execute when at least one build cause matches the expected type.
<4> Get the full list of causes for the current build.
<5> Check if there is only one cause for the current build and that it matches the expected type.
<6> This step will execute when there is only one build cause and it matches the expected type.

*Known `Cause` types*:

* BuildResultTrigger -
link:http://javadoc.jenkins.io/plugin/buildresult-trigger/org/jenkinsci/plugins/buildresulttrigger/BuildResultTriggerCause.html[`org.jenkinsci.plugins.buildresulttrigger.BuildResultTriggerCause`],
* CLICause -
link:http://javadoc.jenkins-ci.org/hudson/cli/BuildCommand.CLICause.html[`hudson.cli.BuildCommand$CLICause`]
* FSTrigger -
link:http://javadoc.jenkins-ci.org/fstrigger/org/jenkinsci/plugins/fstrigger/FSTriggerCause.html[`org.jenkinsci.plugins.fstrigger.FSTriggerCause`],
* IvyTrigger -
link:http://javadoc.jenkins-ci.org/ivytrigger/org/jenkinsci/plugins/ivytrigger/IvyTriggerCause.html[`org.jenkinsci.plugins.ivytrigger.IvyTriggerCause`],
* LegacyCodeCause -
link:http://javadoc.jenkins-ci.org/hudson/model/Cause.LegacyCodeCause.html[`hudson.model.Cause$LegacyCodeCause`] _(Deprecated since 2009-02-08)_
* RemoteCause -
link:http://javadoc.jenkins-ci.org/hudson/model/Cause.RemoteCause.html[`hudson.model.Cause$RemoteCause`]
* SCMTrigger -
link:http://javadoc.jenkins-ci.org/hudson/triggers/SCMTrigger.SCMTriggerCause.html[`hudson.triggers.SCMTrigger$SCMTriggerCause`],
* ScriptTrigger -
link:http://javadoc.jenkins-ci.org/scripttrigger/org/jenkinsci/plugins/scripttrigger/ScriptTriggerCause.html[`org.jenkinsci.plugins.scripttrigger.ScriptTriggerCause`],
* TimerTrigger -
link:http://javadoc.jenkins-ci.org/hudson/triggers/TimerTrigger.TimerTriggerCause.html[`hudson.triggers.TimerTrigger$TimerTriggerCause`],
* UpstreamCause -
link:http://javadoc.jenkins-ci.org/hudson/model/Cause.UpstreamCause.html[`hudson.model.Cause$UpstreamCause`]
* UserIdCause -
link:http://javadoc.jenkins-ci.org/hudson/model/Cause.UserIdCause.html[`hudson.model.Cause$UserIdCause`]
* URLTrigger -
link:http://javadoc.jenkins-ci.org/urltrigger/org/jenkinsci/plugins/urltrigger/URLTriggerCause.html[`org.jenkinsci.plugins.urltrigger.URLTriggerCause`],
* UserCause -
link:http://javadoc.jenkins-ci.org/hudson/model/Cause.UserCause.html[`hudson.model.Cause$UserCause`] _(Deprecated: use "UserIdCause")_
* UserIdCause -
link:http://javadoc.jenkins-ci.org/hudson/model/Cause.UserIdCause.html[`hudson.model.Cause$UserIdCause`]


=== Current build status

[NOTE]
====
This condition has not been translated yet.

The source is available on GitHub in
link:https://github.com/jenkinsci/run-condition-plugin/blob/master/src/main/java/org/jenkins_ci/plugins/run_condition/core/StatusCondition.java[StatusCondition.java]
====

Run if the current build status is within the configured range.

This condition will run the build step when the current build status is
equal to, or better than the "Worst status" and
is equal to or worse than the "Best status".

In Pipeline this value is accessed via `currentBuild.result`,
but the underlying values are the same.  The values and ordering are defined by the
link:http://javadoc.jenkins.io/hudson/model/Result.html[hudson.model.Result] class.
However, `currentBuild.result` is not always set.

Result Values (best to worst): `SUCCESS`, `UNSTABLE`, `FAILURE`, `NOT_BUILT`, and `ABORTED`.

// TODO: Determine how to implement isBetterOrEqualTo and isWorseOrEqualTo
// for this example
// Related: https://issues.jenkins-ci.org/browse/JENKINS-41275

.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { false }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (false)
        echo 'Example step.' // <1>
    }
}
----
<1> This step will never be executed.


=== Day of week

[NOTE]
====
This condition has not been translated yet.

The source is available on GitHub in
link:https://github.com/jenkinsci/run-condition-plugin/blob/master/src/main/java/org/jenkins_ci/plugins/run_condition/core/DayCondition.java[DayCondition.Java]
====

Only run on specific days of the week.

Parameter: Days - Weekdays, Weekends, Select Days (Mon,Tue,Wed,Thu,Fri,Sat,Sun)

Option: "Use build time"

.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { false }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (false)
        echo 'Example step.' // <1>
    }
}
----
<1> This step will never be executed.

=== Execute Shell

[NOTE]
====
This condition has not been translated yet.

The source is available on GitHub in
link:https://github.com/jenkinsci/run-condition-plugin/blob/master/src/main/java/org/jenkins_ci/plugins/run_condition/contributed/ShellCondition.java[ShellCondition.java]
and
link:https://github.com/jenkinsci/run-condition-plugin/blob/master/src/main/java/org/jenkins_ci/plugins/run_condition/contributed/CommandInterperterCondition.java[CommandInterperterCondition.java]
====

Runs a shell script (defaults to sh, uses same configuration as shell build step)
for checking the condition.

The script will be run with the workspace as the current directory.


.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { false }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (false)
        echo 'Example step.' // <1>
    }
}
----
<1> This step will never be executed.

=== Execute Windows Batch

[NOTE]
====
This condition has not been translated yet.

The source is available on GitHub in
link:https://github.com/jenkinsci/run-condition-plugin/blob/master/src/main/java/org/jenkins_ci/plugins/run_condition/contributed/BatchFileCondition.java[BatchFileCondition.java]
and
link:https://github.com/jenkinsci/run-condition-plugin/blob/master/src/main/java/org/jenkins_ci/plugins/run_condition/contributed/CommandInterperterCondition.java[CommandInterperterCondition.java]
====

Runs a Windows batch script for checking the condition.

The script will be run with the workspace as the current directory.


.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { false }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (false)
        echo 'Example step.' // <1>
    }
}
----
<1> This step will never be executed.

=== Execution node

[NOTE]
====
This condition has not been translated yet.

The source is available on GitHub in
link:https://github.com/jenkinsci/run-condition-plugin/blob/master/src/main/java/org/jenkins_ci/plugins/run_condition/core/NodeCondition.java[NodeCondition.java]
====

Run only on selected nodes.


.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { false }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (false)
        echo 'Example step.' // <1>
    }
}
----
<1> This step will never be executed.

=== File exists

[NOTE]
====
This condition has not been translated yet.
====

// TODO: use the fileExists() step

Run if the file exists.
The file is expanded using the Token Macro Plugin.
If the file is relative, then it is relative to the Base directory.
If the file is absolute, then it will be tested on the Node that contains the Base directory (the master for $JENKINS_HOME and Artifacts dir).

.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { false }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (false)
        echo 'Example step.' // <1>
    }
}
----
<1> This step will never be executed.

=== Files match

[NOTE]
====
This condition has not been translated yet.

This like file exists but checks for directory an then uses a pattern not a specific file.

The source is available on GitHub in
link:https://github.com/jenkinsci/run-condition-plugin/blob/master/src/main/java/org/jenkins_ci/plugins/run_condition/core/FilesMatchCondition.java[FilesMatchCondition.java]
====

Run if one or more files match the selectors.
Separate multiple includes or excludes patterns with a comma. e.g. Includes "target/site/**/*.html,target/site/images/" Excludes "**/*.gif"
If no includes pattern is configured, then the pattern "**" will be used, which matches all files in the directory and all sub directories.
The includes and excludes are Ant Patterns.


.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { false }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (false)
        echo 'Example step.' // <1>
    }
}
----
<1> This step will never be executed.

=== Numerical comparison

[NOTE]
====
This condition has not been translated yet.
====

// TODO: Convert to integer and ==

Run if the numerical comparison is true.
The Left hand side and the Right hand side will be expanded with the Token Macro Plugin.
Both arguments must evaluate to a number.
Check out the tokens provided by the Static Code Analysis Plugins for some awesome conditional execution options.


.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { false }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (false)
        echo 'Example step.' // <1>
    }
}
----
<1> This step will never be executed.

=== Regular expression match

[NOTE]
====
This condition has not been translated yet.
====

// TODO: See Boolean condition.


Runs if the Expression matches the Label.
Both the Expression and the Label will be expanded with the Token Macro Plugin.
The Expression is a regular expression using the Java syntax.


.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { false }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (false)
        echo 'Example step.' // <1>
    }
}
----
<1> This step will never be executed.

=== Strings match

[NOTE]
====
This condition has not been translated yet.
====

Run if the two strings are the same.
The match can me made case insensitive by checking the box.

There are several complications to consider when converting this condition to Pipeline.
First, the condition expands the Tokens in both of the strings,
which is not be possible in the Pipeline code.
Second, Groovy, allows variables to be `null`,
which will require special checking.
Finally, Groovy supports two distinct types of strings,
String and GString, which may require additional checks.

Instead, any tokens in the strings will need to be translated to Pipeline,
and then the resulting strings compared.



.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { false }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (false)
        echo 'Example step.' // <1>
    }
}
----
<1> This step will never be executed.


=== Time

[NOTE]
====
This condition has not been translated yet.
The source is available on GitHub in
link:https://github.com/jenkinsci/run-condition-plugin/blob/master/src/main/java/org/jenkins_ci/plugins/run_condition/core/TimeCondition.java[TimeCondition.java]
====

Only run during a certain period of the day.
The time is entered in 24 hour format, e.g. 5:03, 09:00, 22:45.
The time zone is the time zone set on the Jenkins master.
The time resolution is 1 minute, and the start minute and end minute are included in the range. i.e. 00:00 to 23:59 would match the whole day

.Pipeline
[pipeline]
----
// Declarative //
stage ('Example') {
    when {
        expression { false }
    }
    steps {
        echo 'Example step.' // <1>
    }
}
// Script //
stage ('Example') {
    if (false)
        echo 'Example step.' // <1>
    }
}
----
<1> This step will never be executed.
