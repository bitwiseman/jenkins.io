---
layout: post
title: "Declarative Pipeline: Notifications and Shared Libraries"
tags:
- tutorial
- pipeline
- declarative
- plugins
- notifications
- slack
- hipchat
- emailext
author: lnewman
---

NOTE: This is a guest post by link:https://github.com/bitwiseman[Liam Newman],
Technical Evangelist at link:https://cloudbees.com[CloudBees].

**Declare Your Pipelines!**
link:/blog/2017/02/03/declarative-pipeline-ga/[Declarative Pipeline 1.0 is here]!
This is the third post in a series showing some of the cool features of
link:/doc/book/pipeline/syntax/#declarative-pipeline[Declarative Pipeline].


In the
link:/blog/2017/02/10/declarative-html-publisher/[previous blog post],
we converted Scripted Pipeline to a Declarative Pipeline with descriptive stages
and `post` blocks.  In one of those `post&#123; }`  blocks, we included a placeholder for
sending notifications.

In this blog post, we'll pull in the notification method we created for
link:/blog/2016/07/18/pipline-notifications/[Sending Notifications in Pipeline].
We'll show how the structure of
Then we'll move that notification sending method into shared library, letting
use call it from other projects and keeping our `Jenkinsfile` concise and
understandable.

== Setup

The setup for this post is a continuation of the previous.
I've used a new branch
link:https://github.com/bitwiseman/hermann[my same fork] of the
link:https://github.com/reiseburo/hermann[hermann project]:
link:https://github.com/bitwiseman/hermann/tree/blog/declarative/notifications[`blog/add-declarative/notifications`].
I've set up a Multibranch Pipeline and pointed it at my repository
the same as did it previous post.
Also the same as before, I've set this Pipeline's Git configuration to
automatically "Clean after checkout".

In addition, I still have my targets setup from the
"link:/blog/2016/07/18/pipline-notifications/[Sending Notifications in Pipeline]" blog post.
Take a look there for help setting up the
plugin:slack[Slack],
plugin:hipchat[HipChat],
and plugin:email-ext[Email-ext]
plugins.


Here's the final form of the Declarative Pipeline from the previous post:

[pipeline]
----
// Declarative //
pipeline {
  agent {
    // Use docker container
    docker {
      image 'ruby:2.3'
    }
  }
  options {
    // Only keep the 10 most recent builds
    buildDiscarder(logRotator(numToKeepStr:'10'))
  }
  stages {
    stage ('Install') {
      steps {
        // install required gems
        sh 'bundle install'
      }
    }
    stage ('Build') {
      steps {
        // build
        sh 'bundle exec rake build'
      }

      post {
        success {
          // Archive the built artifacts
          archive includes: 'pkg/*.gem'
        }
      }
    }
    stage ('Test') {
      steps {
        // run tests with coverage
        sh 'bundle exec rake spec'
      }

      post {
        success {
          // publish html
          publishHTML target: [
              allowMissing: false,
              alwaysLinkToLastBuild: false,
              keepAll: true,
              reportDir: 'coverage',
              reportFiles: 'index.html',
              reportName: 'RCov Report'
            ]
        }
      }
    }
  }
  post {
    always {
      echo "Send notifications for result: ${currentBuild.result}"
    }
  }
}
// Scripted //
----


== Preparing for Notifications

The Pipeline above has a final `always` block that prints a message to the status log,
but doesn't print anything at the start of the run.
The final form of the Pipeline in the original blog post called the same method twice,
once at the start and once at the end of the run.
Let's start by doing that here as well.

[source, groovy]
----
pipeline {
  /* ... unchanged ... */
  stages {
    stage ('Start') {
      steps {
        // send build started notifications
        sendNotifications 'STARTED'
      }
    }
    /* ... unchanged ... */
  }
  post {
    always {
      sendNotifications currentBuild.result
    }
  }
}

def sendNotifications(String buildStatus = 'STARTED') {
  echo "Send notifications for run: ${buildStatus}"
}
----

.Declarative is still Jenkins Pipeline 
****
Jenkins Declarative Pipeline is still *Jenkins*, still *Pipeline*, and still *Groovy*.
Declarative Pipeline - everything inside
the `pipeline {}` block - is a domain-specific subset is Groovy, but outside that
we can still access all the facilities of Java, Groovy, and Scripted Pipeline.

Looking at the method definition above, some of you will be saying,
"Wait minute, wasn't Declarative Pipeline was supposed to get me away from
Groovy, function definitions, and conditional logic?"
When I first saw this, that's certainly what I said, only with a few more expletives.

Once I got past the original shock and started working with it,
I found Declarative still being Groovy was actually a huge advantage.
Coming from Scripted Pipeline, it meant I was already familiar with the basic syntax of Declarative Pipeline.
For beginning Pipeline users, I this the same will be true in the other direction -
the basic syntax of Declarative Pipeline is simpler introduction to Groovy that is
used through out Pipeline.
As we'll see in the remainder of this post, Declarative and Scripted Pipeline both being Groovy
makes building up from simple to more complex Pipelines much smoother.

Declarative Pipeline provides a structured way of *declaring* the overall flow of Steps in our pipeline.
The complex logic and technology-specific work is handled by Steps.
At the same time, Declarative doesn't care about how those Steps are implemented.
Many Steps come from plugins, but here we've essentially created a Step called
`sendNotifications` that takes a parameter
and does some work based on that. When reviewing the overall structure of our Pipeline,
we don't need to know the implementation details of Step.
****

== Adding Notifications

Next I'll pull in the code for the `sendNotification` method from the original blog post.
I wrote the method to only depend on the one parameter and the Steps from the
three notification plugins.
Like I said, Declarative is still Pipeline -
we'll just copy and paste this code in and,
since I'm running on the same master with the same configuration,
it should just work.

[source, groovy]
----
pipeline {
  /* ... unchanged ... */
}

def sendNotifications(String buildStatus = 'STARTED') {
  // build status of null means successful
  buildStatus =  buildStatus ?: 'SUCCESSFUL'

  // Default values
  def colorName = 'RED'
  def colorCode = '#FF0000'
  def subject = "${buildStatus}: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]'"
  def summary = "${subject} (${env.BUILD_URL})"
  def details = """<p>STARTED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]':</p>
    <p>Check console output at &QUOT;<a href='${env.BUILD_URL}'>${env.JOB_NAME} [${env.BUILD_NUMBER}]</a>&QUOT;</p>"""

  // Override default values based on build status
  if (buildStatus == 'STARTED') {
    color = 'YELLOW'
    colorCode = '#FFFF00'
  } else if (buildStatus == 'SUCCESSFUL') {
    color = 'GREEN'
    colorCode = '#00FF00'
  } else {
    color = 'RED'
    colorCode = '#FF0000'
  }

  // Send notifications
  slackSend color: colorCode, message: summary

  hipchatSend color: color, notify: true, message: summary

  emailext (
      to: 'bitwiseman@bitwiseman.com',
      subject: subject,
      body: details,
      recipientProviders: [[$class: 'DevelopersRecipientProvider']]
    )
}
----

image::/images/post-images/2017-02-14/blueocean-notifications.png[Global Pipeline Library, role="center"]

== Move Notifications to Shared Library

Our current pipeline is pretty good, we have our Declarative Pipeline sending notifications.
However, the notification method taking up about a third of our `Jenkinsfile` is a bit of a distraction.
Also, as Jenkins admin, I'd rather share that notification method among all my projects
without copying it to each new project and then having maintain all the copies.
I want to move that method to a Shared Library.

Shared Libraries are not specific to Declarative. They were released in their
current form several months ago and were functional and useful in Scripted Pipeline.
Not every method like this one should go into a Shared Library,
but Declarative's focus on overall pipeline flow makes it much clearer what
parts of a pipeline are candidates for moving to a shared library.


=== Setup a Shared Library

I've created a simple shared library repository for this series of posts, called
link:https://github.com/bitwiseman/jenkins-pipeline-shared[bitwiseman/jenkins-pipeline-shared].
The Shared Library functionality has too many configuration options to cover in one post.
I've chosen to set mine up a "Global" Library, accessible from any project on my Jenkin master.
Under "Manage Jenkins" -> "Configure System" -> "Global Pipeline Libraries",
I've chosen the name `bitwiseman-shared` and pointed it at my repository.
I've set the default branch to for the library to `master`, but I'll override that in my pipeline.

image::/images/post-images/2017-02-14/shared-library.png[Global Pipeline Library, role="center"]

=== Move the code to the Library

Moving a method to a Shared Library involves creating a file with the name of our
method, adding our method to that file as a `call()` method, adding an optional
help text file to match, and seeing if we need to add a `@Library` directive to
our `Jenkinsfile`.

There are few limitation for methods in Shared Libraries, but they don't apply here.
The minimal set of dependencies for `sendNotifications` means I can once again
basically copy and paste the code across and add short bit of help text for completeness.
I'll check this change into a branch name in the library,
`blog/declarative/notifications` the same as my branch in the other repository.
This will let me make changes on the master branch later without breaking this example.
I'll use use the `@Library` directive to tell Jenkins to use that version with this Pipeline.

.vars/sendNotifications.groovy
[source, groovy]
----
#!/usr/bin/env groovy

/**
 * Send notifications based on build status string
 */
def call(String buildStatus = 'STARTED') {
  // build status of null means successful
  buildStatus =  buildStatus ?: 'SUCCESSFUL'

  // Default values
  def colorName = 'RED'
  def colorCode = '#FF0000'
  def subject = "${buildStatus}: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]'"
  def summary = "${subject} (${env.BUILD_URL})"
  def details = """<p>STARTED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]':</p>
    <p>Check console output at &QUOT;<a href='${env.BUILD_URL}'>${env.JOB_NAME} [${env.BUILD_NUMBER}]</a>&QUOT;</p>"""

  // Override default values based on build status
  if (buildStatus == 'STARTED') {
    color = 'YELLOW'
    colorCode = '#FFFF00'
  } else if (buildStatus == 'SUCCESSFUL') {
    color = 'GREEN'
    colorCode = '#00FF00'
  } else {
    color = 'RED'
    colorCode = '#FF0000'
  }

  // Send notifications
  slackSend (color: colorCode, message: summary)

  hipchatSend (color: color, notify: true, message: summary)

  emailext (
      to: 'bitwiseman@bitwiseman.com',
      subject: subject,
      body: details,
      recipientProviders: [[$class: 'DevelopersRecipientProvider']]
    )
}
----

.vars/sendNotifications.txt
[source]
----
<strong>sendNotifications(buildStatus='STARTED')</strong>

<p>
    Sends notifications via HipChat, Slack, and email.
    Defaults the sending "Started" notification.
    Pass the build status string and it customize the notifications based on status.
</p>
----

.Jenkinsfile
[pipeline]
----
// Declarative //
#!groovy
@Library('bitwiseman-shared@blog/declarative/notifications') _

pipeline {
  agent {
    // Use docker container
    docker {
      image 'ruby:2.3'
    }
  }
  options {
    // Only keep the 10 most recent builds
    buildDiscarder(logRotator(numToKeepStr:'10'))
  }
  stages {
    stage ('Start') {
      steps {
        // send build started notifications
        sendNotifications 'STARTED'
      }
    }
    stage ('Install') {
      steps {
        // install required bundles
        sh 'bundle install'
      }
    }
    stage ('Build') {
      steps {
        // build
        sh 'bundle exec rake build'
      }

      post {
        success {
          // Archive the built artifacts
          archive includes: 'pkg/*.gem'
        }
      }
    }
    stage ('Test') {
      steps {
        // run tests with coverage
        sh 'bundle exec rake spec'
      }

      post {
        success {
          // publish html
          publishHTML target: [
              allowMissing: false,
              alwaysLinkToLastBuild: false,
              keepAll: true,
              reportDir: 'coverage',
              reportFiles: 'index.html',
              reportName: 'RCov Report'
            ]
        }
      }
    }
  }
  post {
    always {
      sendNotifications currentBuild.result
    }
  }
}
// Scripted //
----


== Conclusion
In this post we added notifications to our Declarative Pipeline.
I was pleased to see how little we had to disrupt the existing
flow of our pipeline to do so. The changes were the start and
end of the file with no reformatting elsewhere.
Then with the help of the Shared Library feature,
we've moved the implementation of `sendNotifications` out of
`Jenkinsfile`.  This will let easily reuse that code in other
projects and maintains the clarity of our Pipeline.
In the next post, we'll look at running Sauce OnDemand with
xUnit Reporting in Declarative Pipeline.

== Links

* plugin:pipeline-model-definition[Declarative Pipeline plugin]
* link:/doc/book/pipeline/syntax/#declarative-pipeline[Declarative Pipeline Syntax Reference]
* link:https://github.com/bitwiseman/hermann/tree/blog/declarative/notifications[Pipeline source for this post]
* link:https://github.com/bitwiseman/jenkins-pipeline-shared/tree/blog/declarative/notifications[Pipeline Shared Library source for this post]
