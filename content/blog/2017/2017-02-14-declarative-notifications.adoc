---
layout: post
title: "Declarative Pipeline: Notifications and Shared Libraries"
tags:
- tutorial
- pipeline
- declarative
- plugins
- notifications
- slack
- hipchat
- emailext
author: lnewman
---

NOTE: This is a guest post by link:https://github.com/bitwiseman[Liam Newman],
Technical Evangelist at link:https://cloudbees.com[CloudBees].

**Declare Your Pipelines!**
link:/blog/2017/02/03/declarative-pipeline-ga/[Declarative Pipeline 1.0 is here]!
This is the third post in a series showing some of the cool features of
link:/doc/book/pipeline/syntax/#declarative-pipeline[Declarative Pipeline].


In the
link:/blog/2017/02/10/declarative-html-publisher/[previous post],
we converted a Scripted Pipeline to a Declarative Pipeline, adding descriptive stages
and `post` sections.  In one of those `post` blocks, we included a placeholder for
sending notifications.

In this blog post, we'll pull in the notification method we created for
link:/blog/2016/07/18/pipline-notifications/[Sending Notifications in Pipeline],
integrating notification services Slack, HipChat, and Email, into our Declarative Pipeline.
Then we'll move that method into a shared library,
keeping our `Jenkinsfile` concise and understandable,
and letting use call that method from other projects.

== Setup

The setup for this post is a almost the same as the
link:/blog/2017/02/10/declarative-html-publisher/[my previous Declarative Pipeline post].
I've used a new branch in
link:https://github.com/bitwiseman/hermann[my fork] of the
link:https://github.com/reiseburo/hermann[Hermann project]:
link:https://github.com/bitwiseman/hermann/tree/blog/declarative/notifications[`blog/add-declarative/notifications`].
I'd already set up a Multibranch Pipeline and pointed it at my repository,
so the new branch will be picked up and built automatically.

I still have my private notification targets (where we'll send notifications) which I created for the
"link:/blog/2016/07/18/pipline-notifications/[Sending Notifications in Pipeline]" blog post.
Take a look at that post to review how to I setup the
plugin:slack[Slack],
plugin:hipchat[HipChat],
and plugin:email-ext[Email-ext]
plugins to use those channels.


== Preparing for Notifications

We'll start from the same Pipeline we had at the end of the previous post.

It works quiet well, but only only has  that final `always` directive that prints a message to the console log,
but doesn't print anything at the start of the run.
The Scripted Pipeline in the original blog post called the same method twice,
once at the start of the run and once at the end.
Let's start by replicating that here as well.

[source, groovy]
----
pipeline {
  /* ... unchanged ... */
  stages {
    stage ('Start') {
      steps {
        // send build started notifications
        sendNotifications 'STARTED'
      }
    }
    /* ... unchanged ... */
  }
  post {
    always {
      sendNotifications currentBuild.result
    }
  }
}

def sendNotifications(String buildStatus = 'STARTED') {
  echo "Send notifications for run: ${buildStatus}"
}
----

// TODO: still re-editing this section.
.Declarative is still Jenkins Pipeline
****
Looking at the method definition above, some of you will be saying,
"Wait a minute, wasn't Declarative Pipeline supposed to get me away from
Groovy, function definitions, and conditional logic?"
When I first saw this, that's certainly what I said, only with a few more expletives.

Once I got past the original shock and started working with it,
I found that Declarative still being Groovy was actually a huge advantage.
Declarative Pipeline - everything inside the `pipeline {}` section -
is a
link:https://en.wikipedia.org/wiki/Domain-specific_language[domain specific language]
that uses Groovy syntax,
and outside the `pipeline {}` section
we can still access all the facilities of Groovy and Scripted Pipeline.

Jenkins Declarative Pipeline is still *Jenkins Pipeline*.

This meant, as an expert in Scripted Pipeline, I was already familiar with the
basic syntax of Declarative Pipeline.
For users entirely new to Jenkins Pipeline, I think this the same will be true in the other direction -
the basic syntax of Declarative Pipeline is good introduction to the Groovy syntax that is
used throughout Pipeline.
As we'll see in the remainder of this post, Declarative and Scripted Pipeline both being Groovy
makes building up from simple to more complex Pipelines much smoother.

Declarative Pipeline provides a structured way of *declaring* the overall flow of Steps in our pipeline.
The complex logic and technology-specific work is handled by Steps.
At the same time, Declarative doesn't care about how those Steps are implemented.
Many Steps come from plugins, but here we've essentially created a Step called
`sendNotifications` that takes a parameter and does some work based on that.
When reviewing the overall structure of our Pipeline,
we don't need to know the implementation details of Step.
****

== Adding Notifications

Next, I'll pull in the code for the `sendNotification` method from the original blog post.
I wrote the method to only depend on the one parameter and the Steps from the
three notification plugins.
Like I said, Declarative is still Pipeline -
we'll just copy and paste this code in and,
since I'm running on the same master with the same configuration,
it should just work.

[source, groovy]
----
pipeline {
  /* ... unchanged ... */
}

def sendNotifications(String buildStatus = 'STARTED') {
  // build status of null means successful
  buildStatus =  buildStatus ?: 'SUCCESSFUL'

  // Default values
  def colorName = 'RED'
  def colorCode = '#FF0000'
  def subject = "${buildStatus}: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]'"
  def summary = "${subject} (${env.BUILD_URL})"
  def details = """<p>STARTED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]':</p>
    <p>Check console output at &QUOT;<a href='${env.BUILD_URL}'>${env.JOB_NAME} [${env.BUILD_NUMBER}]</a>&QUOT;</p>"""

  // Override default values based on build status
  if (buildStatus == 'STARTED') {
    color = 'YELLOW'
    colorCode = '#FFFF00'
  } else if (buildStatus == 'SUCCESSFUL') {
    color = 'GREEN'
    colorCode = '#00FF00'
  } else {
    color = 'RED'
    colorCode = '#FF0000'
  }

  // Send notifications
  slackSend color: colorCode, message: summary

  hipchatSend color: color, notify: true, message: summary

  emailext (
      to: 'bitwiseman@bitwiseman.com',
      subject: subject,
      body: details,
      recipientProviders: [[$class: 'DevelopersRecipientProvider']]
    )
}
----

image::/images/post-images/2017-02-14/blueocean-notifications.png[Blue Ocean Run with Notifications, role="center", width=800]

== Moving Notifications to Shared Library

Our current pipeline is pretty good, we have our Declarative Pipeline sending notifications.
However, the notification method takes up about a third of our `Jenkinsfile`.
It is a bit of a distraction.
Also, as Jenkins admin, I'd like to share that notification method among all my projects
without copying it to each new project and then having maintain all the copies.
I want to move that method to a
link:/doc/book/pipeline/shared-libraries/[Shared Library].

Shared Libraries are not specific to Declarative. They were released in their
current form several months ago and were useful in Scripted Pipeline.
Since Declarative is still Pipeline, we can use them here as well.
While not every method like this one should go into a Shared Library,
Declarative's focus on overall pipeline flow makes it much clearer what
parts of a pipeline are candidates for moving to a shared library.
// TODO: Might be a good idea to put a short statement of how you judge what should and shouldn't go into a Shared Library

=== Setting up a Shared Library

I've created a simple shared library repository for this series of posts, called
link:https://github.com/bitwiseman/jenkins-pipeline-shared[jenkins-pipeline-shared].
The shared library functionality has too many configuration options to cover in one post.
I've chosen to configure this library as a "Global Pipeline Library",
accessible from any project on my Jenkins master.
To setup a "Global Pipeline Library", navigated to "Manage Jenkins" -> "Configure System"
in the Jenkins web UI.
Then, under "Global Pipeline Libraries", I've added a new library.
I've the name `bitwiseman-shared`, pointed it at my repository,
and set the default branch for the library to `master` (we ),
but I'll override that in my `Jenkinsfile`.

image::/images/post-images/2017-02-14/shared-library.png[Global Pipeline Library, role="center", width=800]

=== Moving the Code to the Library

Moving a method or class to a library involves creating a file with the name of our method,
adding our method to that file as a `call()` method,
and removing the method from our local `Jenkinsfile`.
We'll also have the option to add help text to the library.
Library's can be set to load "implicitly",
making their default branch automatically available to all Pipelines,
or they can be loaded manually using a `@Library` annotation.
The branch for implicitly loaded libraries can also be overridden using the `@Library` annotation.

There are a few limitations for methods in Shared Libraries, but they don't apply here.
The minimal set of dependencies for `sendNotifications` means we can once again
basically copy-and-paste the code across.
We'll check this change into a branch in the library, named
`blog/declarative/notifications` the same as my branch in the `hermann` repository.
This will let us make changes on the master branch later without breaking this example.
We'll use use the `@Library` directive to tell Jenkins to use that branch's version
of the library with this Pipeline.

.Jenkinsfile
[pipeline]
----
// Declarative //
#!groovy
@Library('bitwiseman-shared@blog/declarative/notifications') _ // <1>

pipeline {
  agent {
    // Use docker container
    docker {
      image 'ruby:2.3'
    }
  }
  options {
    // Only keep the 10 most recent builds
    buildDiscarder(logRotator(numToKeepStr:'10'))
  }
  stages {
    stage ('Start') {
      steps {
        // send build started notifications
        sendNotifications 'STARTED'
      }
    }
    stage ('Install') {
      steps {
        // install required bundles
        sh 'bundle install'
      }
    }
    stage ('Build') {
      steps {
        // build
        sh 'bundle exec rake build'
      }

      post {
        success {
          // Archive the built artifacts
          archive includes: 'pkg/*.gem'
        }
      }
    }
    stage ('Test') {
      steps {
        // run tests with coverage
        sh 'bundle exec rake spec'
      }

      post {
        success {
          // publish html
          publishHTML target: [
              allowMissing: false,
              alwaysLinkToLastBuild: false,
              keepAll: true,
              reportDir: 'coverage',
              reportFiles: 'index.html',
              reportName: 'RCov Report'
            ]
        }
      }
    }
  }
  post {
    always {
      sendNotifications currentBuild.result
    }
  }
}
// Scripted //
----
<1> The `_` here is intentional.
link:https://en.wikipedia.org/wiki/Java_annotation[Java/Groovy Annotations]
such `@Library` must be applied to an element.
That is often a `using` statement, but that isn't needed here so by convention we use an `_`.

.vars/sendNotifications.groovy
[source, groovy]
----
#!/usr/bin/env groovy

/**
 * Send notifications based on build status string
 */
def call(String buildStatus = 'STARTED') {
  // build status of null means successful
  buildStatus =  buildStatus ?: 'SUCCESSFUL'

  // Default values
  def colorName = 'RED'
  def colorCode = '#FF0000'
  def subject = "${buildStatus}: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]'"
  def summary = "${subject} (${env.BUILD_URL})"
  def details = """<p>STARTED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]':</p>
    <p>Check console output at &QUOT;<a href='${env.BUILD_URL}'>${env.JOB_NAME} [${env.BUILD_NUMBER}]</a>&QUOT;</p>"""

  // Override default values based on build status
  if (buildStatus == 'STARTED') {
    color = 'YELLOW'
    colorCode = '#FFFF00'
  } else if (buildStatus == 'SUCCESSFUL') {
    color = 'GREEN'
    colorCode = '#00FF00'
  } else {
    color = 'RED'
    colorCode = '#FF0000'
  }

  // Send notifications
  slackSend (color: colorCode, message: summary)

  hipchatSend (color: color, notify: true, message: summary)

  emailext (
      to: 'bitwiseman@bitwiseman.com',
      subject: subject,
      body: details,
      recipientProviders: [[$class: 'DevelopersRecipientProvider']]
    )
}
----

// TODO: summary image of "everything working".

== Conclusion
In this post, we added notifications to our Declarative Pipeline.
I was pleased to see how little we had to disrupt the existing flow of our pipeline to do so.
The changes were at the start and end of the file with no reformatting elsewhere.
Then with the help of the Shared Library feature,
we moved the implementation of `sendNotifications` out of `Jenkinsfile`.
This will let us easily reuse that code in other projects and maintains the clarity of our Pipeline.
In the next post, we'll cover more about shared libraries and how to
run Sauce OnDemand with xUnit Reporting in Declarative Pipeline.

== Links

* plugin:pipeline-model-definition[Declarative Pipeline plugin]
* link:/doc/book/pipeline/syntax/#declarative-pipeline[Declarative Pipeline Syntax Reference]
* link:/doc/book/pipeline/shared-libraries/[Shared Library reference]
* link:https://github.com/bitwiseman/hermann/tree/blog/declarative/notifications[Pipeline source for this post]
* link:https://github.com/bitwiseman/jenkins-pipeline-shared/tree/blog/declarative/notifications[Pipeline Shared Library source for this post]
